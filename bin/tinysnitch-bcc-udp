#!/usr/bin/python2
#
# Copyright (c) 2019 Cloudflare, Inc.
# Licensed under the Apache License, Version 2.0 (the "License")
#
# 15-Jan-2019 Thomas Lefebvre Created this.

from __future__ import print_function
from bcc import BPF
import ctypes as ct
from socket import inet_ntop, AF_INET
from struct import pack

# define BPF program
bpf_text = """
#include <uapi/linux/udp.h>
#include <uapi/linux/ip.h>
#include <net/sock.h>

struct rcv_skb_data_t {
    u32 saddr;
    u32 daddr;
    u16 sport;
    u16 dport;
};
BPF_PERF_OUTPUT(rcv_skb);

static struct udphdr *skb_to_udphdr(const struct sk_buff *skb) { // unstable API. verify logic in udp_hdr() -> skb_transport_header().
    return (struct udphdr *)(skb->head + skb->transport_header);
}

static inline struct iphdr *skb_to_iphdr(const struct sk_buff *skb) { // unstable API. verify logic in ip_hdr() -> skb_network_header().
    return (struct iphdr *)(skb->head + skb->network_header);
}

int kprobe__udp_queue_rcv_skb(struct pt_regs *ctx, struct sock *sk, struct sk_buff *skb) {
    u16 family = sk->__sk_common.skc_family;
    u16 sport = 0, dport = 0;
    struct iphdr *ip = skb_to_iphdr(skb);
    struct udphdr *udp = skb_to_udphdr(skb);
    sport = udp->source;
    dport = udp->dest;
    sport = ntohs(sport);
    dport = ntohs(dport);
    if (family == AF_INET) {
        struct rcv_skb_data_t data = {};
        data.saddr = ip->saddr;
        data.daddr = ip->daddr;
        data.dport = dport;
        data.sport = sport;
        rcv_skb.perf_submit(ctx, &data, sizeof(data));
    }
    return 0;
}

struct sendmsg_data_t {
    u32 pid;
    u32 saddr;
    u32 daddr;
    u16 sport;
    u16 dport;
};
BPF_PERF_OUTPUT(sendmsg_events);

int kprobe__udp_sendmsg(struct pt_regs *ctx, struct sock *sk) {
    u64 pid = bpf_get_current_pid_tgid();
    u16 family = sk->__sk_common.skc_family;
    u16 sport = 0, dport = 0;
    if (family == AF_INET && sk->__sk_common.skc_dport != 0) {
        struct sendmsg_data_t data = {};
        data.pid = pid >> 32;
        data.saddr = sk->__sk_common.skc_rcv_saddr;
        data.sport = sk->__sk_common.skc_num;
        data.daddr = sk->__sk_common.skc_daddr;
        data.dport = sk->__sk_common.skc_dport;
        data.dport = ntohs(data.dport);
        sendmsg_events.perf_submit(ctx, &data, sizeof(data));
    }
    return 0;
}
"""

class Data_sendmsg(ct.Structure):
    _fields_ = [("pid", ct.c_uint), ("saddr", ct.c_uint), ("daddr", ct.c_uint), ("sport", ct.c_ushort), ("dport", ct.c_ushort)]

last_sendmsg = None
def print_sendmsg_event(cpu, data, size):
    global last_sendmsg
    event = ct.cast(data, ct.POINTER(Data_sendmsg)).contents
    val = '%s %s %s %s %s' % (event.pid, inet_ntop(AF_INET, pack('I', event.saddr)), event.sport, inet_ntop(AF_INET, pack('I', event.daddr)), event.dport)
    if val != last_sendmsg:
        print(val)
        last_sendmsg = val

class Data_rcv_skb(ct.Structure):
    _fields_ = [("saddr", ct.c_uint), ("daddr", ct.c_uint), ("sport", ct.c_ushort), ("dport", ct.c_ushort)]

last_rcv_skb = None
def print_rcv_skb_event(cpu, data, size):
    global last_rcv_skb
    event = ct.cast(data, ct.POINTER(Data_rcv_skb)).contents
    val = '0 %s %s %s %s' % (inet_ntop(AF_INET, pack('I', event.saddr)), event.sport, inet_ntop(AF_INET, pack('I', event.daddr)), event.dport)
    if val != last_rcv_skb:
        print(val)
        last_rcv_skb = val

b = BPF(text=bpf_text)

b["sendmsg_events"].open_perf_buffer(print_sendmsg_event)
b["rcv_skb"].open_perf_buffer(print_rcv_skb_event)

while 1:
    b.perf_buffer_poll()
